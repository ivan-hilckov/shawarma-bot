В прошлой беседе мы сформировали план разработки Telegram Mini Apps - "Создание простого Telegram Mini App с использованием HTML, CSS и JavaScript"

Давай конкретизируем его.

Я сделал шаги из документации https://docs.telegram-mini-apps.com/platform/creating-new-app и создал mini app.

Title: "Saurma ot Rayhana"
Description: "Приложение для заказа шаурмы с полным функционалом корзины, системой заказов
WebAppUrl: "https://botgarden.store/"
ShortName: "SaurmaOtRayhanaApp"
URL: "t.me/SaurmaOtRayhanaBot/SaurmaOtRayhanaApp"

Лендинг открылся как приложение.

И дальше, что бы проверить то как работает Telegram Mini App, мне нужно:

1. минимально "Лендинг" костомизировать что бы был функционал нескольких страниц (давай возьмем 2 страницы: Главная и Список заказов пользователя)

Технически я бы хотел это реализовать на чистом JS что бы не тащить историю с компиляцией и стилями.

2. добавить в бота кнопку запуска приложения

давай отбросим в нашем плане все кроме этих дух пунктов, как устроены ландинг страницы описано тут https://github.com/ivan-hilckov/shawarma-bot/blob/main/docs/LANDING_PAGES.md это описание всего проекта https://github.com/ivan-hilckov/shawarma-bot/blob/main/README.md

Помоги сформировать план реализации. Добавь в него документацию на https://core.telegram.org/bots/features и https://core.telegram.org/bots https://core.telegram.org/bots/webapps#initializing-mini-apps

---

План доработки мини-приложения “Шаурма от Райхана”
• Добавить клиентский роутинг между страницами “Главная” и “Список заказов” на фронтенде с помощью чистого HTML/JS (путём скрытия/показа блоков, без использования фреймворков и сборки).
• Добавить кнопку в Telegram-боте (например, на инлайн-клавиатуре) для запуска Mini App (WebApp) прямо из чата.

1. Клиентский роутинг на стороне фронтенда

Telegram Mini Apps по сути являются обычными веб-приложениями, запущенными внутри клиента Telegram ￼. Это означает, что навигацию между разными экранами можно реализовать стандартными методами на HTML/JS, без привлечения сторонних фреймворков. Необходимо сделать две “страницы” – Главную и Список заказов – в рамках одного HTML-документа и переключаться между ними, меняя видимость соответствующих блоков.

Шаги реализации: 1. Разметка HTML: Разделите контент на два контейнера (например, <div>). Один будет соответствовать главной странице, второй – странице списка заказов. Можно присвоить им идентификаторы, например "page-main" и "page-orders". Изначально в CSS задайте второму контейнеру display: none;, чтобы при загрузке показывалась только главная страница. Также добавьте навигационные элементы – например, простое меню в виде ссылок или кнопок «Главная» и «Список заказов», по нажатию на которые будет происходить переключение.

<nav>
  <button onclick="showPage('page-main')">Главная</button>
  <button onclick="showPage('page-orders')">Список заказов</button>
</nav>

<div id="page-main">
  <!-- Контент главной страницы (напр. приветствие, меню товаров) -->
</div>

<div id="page-orders" style="display: none;">
  <!-- Контент страницы со списком заказов (напр. текущие/прошлые заказы пользователя) -->
</div>

    2.	Скрипт переключения: Реализуйте функцию showPage(pageId), которая скрывает оба блока и затем показывает тот, чей id совпадает с переданным аргументом. Вызывать эту функцию при нажатии кнопок навигации. Дополнительно можно отслеживать изменения хэша URL, чтобы поддерживать навигацию через адресную строку (например, #main и #orders) – это улучшит UX, позволяя использовать кнопку «назад» в браузере.

<script>
  function showPage(pageId) {
    // Скрываем оба блока
    document.getElementById('page-main').style.display = 'none';
    document.getElementById('page-orders').style.display = 'none';
    // Показываем выбранный блок
    document.getElementById(pageId).style.display = 'block';
  }

  // При загрузке страницы показываем главную (или ту, что указана в хэше URL)
  const defaultPage = location.hash === '#orders' ? 'page-orders' : 'page-main';
  showPage(defaultPage);

  // Опционально: переключение по изменению URL-хэша (если используете hash routing)
  window.addEventListener('hashchange', () => {
    if (location.hash === '#orders') {
      showPage('page-orders');
    } else {
      showPage('page-main');
    }
  });
</script>

    3.	Инициализация Mini App: Убедитесь, что в HTML подключен скрипт инициализации Telegram WebApp до других скриптов, как указано в документации ￼. Это необходимо, чтобы Telegram-клиент мог связать страницу с вашим ботом:

<head>
  <!-- ... другие теги ... -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>

Если нужно, можно использовать API объекта Telegram.WebApp для получения информации о пользователе, темы и т.д., однако для простого роутинга это не обязательно.

Советы по отладке фронтенда: При разработке протестируйте переключение страниц в обычном браузере: убедитесь, что по нажатию кнопок один контейнер скрывается, другой отображается, и что не возникает JavaScript-ошибок. Для отладки откройте консоль разработчика (DevTools) и проверьте, что функция showPage вызывается и элементы корректно меняют стиль. Кроме того, проверьте адаптивность: так как Mini App будет открываться на мобильных устройствах внутри Telegram, убедитесь, что обе страницы корректно выглядят на маленьких экранах (используйте mobile device toolbar в DevTools).

Если Mini App уже деплоится на свой домен, можно временно открыть страницу напрямую в браузере по адресу https://botgarden.store/, чтобы убедиться в работоспособности роутинга вне Telegram. После этого проверьте работу внутри Telegram: запустите мини-приложение и убедитесь, что навигация между “Главная” и “Список заказов” происходит мгновенно, без перезагрузки страницы.

2. Кнопка в боте для запуска Mini App

Чтобы пользователь мог открыть веб-приложение напрямую из интерфейса бота, нужно добавить специальную кнопку в диалог с ботом. Telegram поддерживает несколько способов запуска Mini App из бота (через кнопку профиля, клавиатуру, inline-режим, ссылку и даже через меню вложений) ￼. В нашем случае самый простой подход — использовать инлайн-клавиатуру с кнопкой Web App. Это такая кнопка, которая при нажатии открывает указанный URL внутри Telegram (в вашем случае – страницу https://botgarden.store/).

Реализация в коде бота:
• Добавление команды или сообщения: Определите, в каком месте бот должен предлагать открыть приложение. Это может быть, например, команда /menu или просто реакция на команду /start, чтобы сразу предложить открыть мини-приложение. В обработчике соответствующей команды отправьте сообщение с текстом и прикреплённой инлайн-клавиатурой.
• Настройка инлайн-кнопки: В разметке ответа (ReplyMarkup) нужно добавить кнопку с параметром web_app. В Bot API такая кнопка описывается объектом InlineKeyboardButton с полем web_app, указывающим URL мини-приложения ￼. В коде на Node.js/TypeScript это может выглядеть, например, так:

// Предполагается, что у вас есть функция для отправки сообщения через API
bot.sendMessage(chatId, "Открыть меню \uD83C\uDF71", {
reply_markup: {
inline_keyboard: [[{ text: "Запустить Shawarma App", web_app: { url: "https://botgarden.store/" } }]]
}
});

Когда пользователь нажмёт эту кнопку “Запустить Shawarma App”, у него в Telegram откроется ваше веб-приложение (мини-приложение) по указанному URL, прямо в интерфейсе чата с ботом. Нет необходимости вручную обрабатывать нажатие — клиент Telegram сам откроет WebView с вашим приложением.

⚠️ Важный момент: убедитесь, что домен botgarden.store привязан к вашему боту через BotFather. Используйте команду /setdomain в чате с @BotFather, выберите вашего бота и укажите домен (без протокола) ￼. Если этого не сделать, Telegram не позволит открыть WebApp, и при нажатии кнопки будет ошибка «Bot domain invalid» – URL не совпадает с привязанным доменом. После установки домена можно также настроить у BotFather описания мини-приложения, если нужно (через Configure Mini App).

    •	Альтернатива – кнопка-меню: Помимо инлайн-кнопки, Telegram предоставляет возможность использовать стандартную кнопку меню (справа от поля ввода) для запуска Web App вместо показа списка команд ￼. Это настраивается через BotFather командой /setmenubutton (или методом setChatMenuButton в Bot API). В рамках данного задания можно не делать этого, но для сведения: закреплённая кнопка меню позволяет пользователю открыть мини-приложение в любой момент из чата, что бывает удобно.

Советы по отладке бота: После внесения изменений перезапустите бота (или пересоберите Docker-контейнер) и проверьте в Telegram. Нажмите кнопку запуска WebApp и убедитесь, что мини-приложение загружается внутри Telegram. Если приложение не открывается, проверьте следующие моменты:
• Правильно ли сформирована кнопка в сообщении (нет ли опечаток в поле web_app или URL).
• Добавлен ли домен через /setdomain (без этого Telegram блокирует открытие URL). При несоответствии домена признак – мгновенное закрытие веб-приложения с сообщением об ошибке.
• Открываются ли логи бота без ошибок: выполните docker-compose logs -f bot (согласно документации репозитория) и посмотрите, нет ли исключений при отправке сообщения с клавиатурой.
• Убедитесь, что бот отправляет именно инлайн-клавиатуру. В контексте Telegram Bot API, web_app кнопки поддерживаются только в инлайн-клавиатурах (InlineKeyboard), а не в обычной ReplyKeyboard. Если использовать ReplyKeyboardMarkup с KeyboardButton.web_app, то кнопка будет отображаться под полем ввода; этот вариант тоже возможен, но обычно инлайн-кнопка в сообщении более заметна.

Для локальной проверки UI веб-приложения вы можете открыть URL в браузере, но отправка данных от Mini App боту (через Telegram.WebApp.sendData, если бы вы это использовали) срабатывает только внутри Telegram. Однако в нашем случае приложение самостоятельное, и взаимодействие с ботом происходит через API, поэтому основное – проверить, что бот по нажатию кнопки открывает нужный URL.

3. Итоговое состояние vs текущее

После выполнения данного плана мини-приложение станет более функциональным и интегрированным с ботом.
• Что было до: Веб-приложение представляло собой единую страницу (основной экран магазина) без внутренней навигации. Пользователь не мог напрямую открыть его из интерфейса бота – запуск происходил, вероятно, через внешнюю ссылку или вообще отсутствовал в бот-интерфейсе.
• Что станет после: Приложение будет иметь простейший SPA-подобный роутинг: из главного экрана можно переключиться на экран списка заказов и обратно без перезагрузки страницы. Навигация выполняется мгновенно на стороне клиента, улучшая UX. В коде бота появится специальная кнопка, по нажатию на которую мини-приложение Shawarma Bot откроется прямо внутри Telegram (WebView). Это упростит пользователям доступ к меню: бот сам открывает встроенное окно с веб-интерфейсом заказа. Таким образом, достигается более тесная интеграция: бот и WebApp работают в связке, обеспечивая бесшовный опыт (seamless experience) для пользователя ￼. В целом, текущий разрозненный функционал превратится в цельное решение, где Telegram-бот способен как принимать текстовые команды, так и предоставлять интерактивный веб-интерфейс для оформления заказов – всё в одном месте.
